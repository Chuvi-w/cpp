Модульное тестирование в Qt
===========================

Модульные тесты:
  Входные данные -> Тестируемый класс -> Ожидаемый результат

Если мы не знаем какой результат ожидать => мы не можем написать тест.

Но запустив тест один раз и посмотрев результат мы можем
написать так называемый **регрессионный тест**.
Т.е. тест, который страхует нас от **регрессий** - ухудшения качества ПО
(когда что-то что уже работало в какой-то версии "ломается" в следующей).

Для использования модульных тестов надо подключить модуль **testlib**.

``` pro
# testlib - библиотека для модульного тестирования
QT       += testlib core gui
```

Пример
------

Тестируемая функция:
``` cpp
// Сумма: a + b
int sum(int a, int b){
  return a + b;
}
```

Модульный тест к ней:
``` cpp
// Класс, который содержит тесты
class AllTests : public QObject {
  Q_OBJECT
private slots: // должны быть приватными
  // Тестирование функции суммирования
  void testSum(){
    QCOMPARE(sum(2,2), 4);
    QCOMPARE(sum(2,3), 5);
  }
};
```

В основной программе все тесты можно запустить так:
```cpp
  QTest::qExec(new AllTests, argc, argv);
```


Подключаем все модули для тестирования
И свой заголовочный файл
Тестирование вычисления максимума
QCOMPARE( вызов_тестируемой_функции, ожидаемое_значение );
Тестирование вычисления факториала
Проверка исключения (ожидаемое исключение)
Если мы оказались в этом месте программы,
то метод факториал не сгенерировал исключение
TDD
0*x*x + 0*x + 0 = 0
Число в строку
Число в строку
Число в строку
[alltests.cpp](alltests.cpp)

Класс, который содержит тесты
Тестирование вычисления максимума
Новый тест для вычисления факториала
Тест для квадратного уравнения
Число в строку до 100
Число в строку от 100 до 199
Число в строку от 200 до 999
Число в строку от 1000 до 999999
Тестирование функции суммирования
[alltests.h](alltests.h)

Сумма: a + b
Факториал
Численное интегрирование
Метод трапеций

[functions.cpp](functions.cpp)

Сумма: a + b = c
Факториал
function - указатель на функцию возвращающую 1
Численное интегрирование
Метод трапеций
[functions.h](functions.h)

Константная функция
Константная функция
y = x   0..1  -> 0.5
y = x^2  x^3/3   0..1  -> 1/3
[integraltest.cpp](integraltest.cpp)

Тестирование интегрирования константной функции
[integraltest.h](integraltest.h)

#define DEBUG1
Число в строку
Обрезаем лишние пробелы в начале и конце
Первая буква в верхнем регистре
[inttostr.cpp](inttostr.cpp)

Модуль с функцией для тестирования
Целое число N в строку
[inttostr.h](inttostr.h)

Подключаем модульные тесты
Вывод числа в строку
Выведем все числа в файл (чтобы посмотреть на них вручную)
freopen("testing.txt", "w", stdout);
QTest::qExec(new SimpleTests());
QTest::qExec(new AllTests, argc, argv);
writeNumbersToFile();
[main.cpp](main.cpp)

return 10;
[myclass.cpp](myclass.cpp)

Тестируемый класс
Вычисление максимума
Вычисление минимума
[myclass.h](myclass.h)

И
QCOMPARE(2 * 2 + 1, 4);
[simpletests.cpp](simpletests.cpp)

Вызывается при инициализации
всех тестов
[simpletests.h](simpletests.h)

Генерируем исключение
Нет решений
Линейное уравнение
Квадратное уравнение
[squareeq.cpp](squareeq.cpp)

Корни квадратного уравнения
Решение квадратного уравнения
[squareeq.h](squareeq.h)

