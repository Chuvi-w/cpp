ООП - принципы: классы, объекты, прототипы
==========================================

Объектно-ориентированное программирование (ООП, OOP): абстракция, инкапсуляция, наследование и полиморфизм
----------------------------------------------------------------------------------------------------------

Парадигма программирования, в которой основные концепции: **объект** и **класс**.

**Класс** - является описанием ещё не существующей сущности (объекта).
 Фактически он описывает устройство объекта, являясь своего рода "чертежом".
Обычно классы разрабатывают таким образом, чтобы их объекты соответствовали объектам предметной области.

**Объект** - сущность, которой можно посылать сообщения, и которая может на них реагировать,
используя свои данные. **Объект** = **экземпляр класса**.
Данные объекта скрыты от остальной программы. Сокрытие данных называется инкапсуляцией.

**Объект** - экземпляр класса, сущность в адресном пространстве вычислительной системы,
появляющаяся при создании экземпляра класса или копирования прототипа.

**Абстрагирование** - выделение набора значимых характеристик объекта, исключая из рассмотрения незначимые.

**Абстракция** - набор всех характеристик объекта, значимых с точки зрения решаемых задач.

**Инкапсуляция** - свойство системы, позволяющее объединить данные и методы,
работающие с ними в классе, и скрыть детали реализации от пользователя.

**Наследование** - свойство системы, позволяющее описать новый класс
на основе уже существующего с частично или полностью заимствующейся функциональностью (данными и методами).
Класс, от которого производится наследование, называется **базовым**, **родительским** или **суперклассом**.
Новый класс - **потомком**, **наследником** (**дочерним**) или **производным** классом.

**Полиморфизм** - возможность использовать объекты с одинаковым
интерфейсом без передачи информации о типе и внутренней структуре объекта.

**Прототип** - объект-образец, по образу и подобию которого создаются другие объекты.
Объекты-копии могут сохранять связь с родительским объектом,
автоматически наследуя изменения в прототипе; эта особенность определяется в рамках конкретного языка.
В языках с прототипированием (например, JavaScript) вместо классов используются объекты-прототипы.

Объявление класса
-----------------
c++ 11 M_PI не определена в режиме __STRICT_ANSI__
#undef __STRICT_ANSI__
const double M_PI = 4.0 * atan(1);
#include <math.h>
Храним координаты точек как
2 отдельных массива
``` cpp
const int POINTS = 100;
double x[POINTS], y[POINTS];
```

Создали структуру точка
``` cpp
struct Point {
  double x, y;
};

// Массив из точек
Point p[140];
// Обращение к элементам массива:
// p[0].x, p[0].y
```

Класс = данные + методы работы
``` cpp
class Point2D {
 public:
  double x, y;

  void move(double dx, double dy) {
    x += dx;
    y += dy;
  }

  // Повернуть точку относительно
  // начала координат
  // angle - в градусах
  void rotate(double angle) {
    // Перевод из градусов в радианы
    // a - угол в радианах
    double a = angle * M_PI / 180.0;
    double
    nx = x * cos(a) - y * sin(a);
    double
    ny = x * sin(a) + y * cos(a);
    x = nx;
    y = ny;
  }
};
```

Модификаторы доступа: public / private / protected
Создание экземпляра
-------------------
Пример использования:
``` cpp
int main() {
  // Два отдельных массива
  x[0] = 1;
  y[0] = 2;
  // ООП
  p[0].x = 1;
  p[0].y = 2;

  Point p1;
  p1.x = 2;

  Point2D p2;
  p2.x = 2;

  Point2D points[100];
  points[10].x = 10.1;
  points[10].y = 10.3;
  points[0].move(1, 2);
  points[1].rotate(1.2);

  Point2D A, B, C;
  A.move(10, 2);

  /*  x[10] = 1;
    y[20] = 2;
    move_point(10, 10, 2); */

  // Динамическая память
  Point2D* p;
  //...
  p = new Point2D;
  p->x = 2;
  p->move(10, 11);
  (*p).move(1, 2);
  delete p;

  // Создаю массив объектов в
  // динамической памяти
  Point2D* pp = new Point2D[10];

  // Удаляю
  delete[] pp;

  return 0;
}
```

[main.cpp](main.cpp)

