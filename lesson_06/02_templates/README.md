<!-- doc.py -->
Базовое применение шаблонов
Без использования шаблонов
T - параметр шаблона
Шаблонная функция
Предусловия
Параметры шаблонов:
типы: class G / typename T
любой из типов: int I
Функция, добавляющая константу
assert(2*2 == 5);
[31_template_min_max/01_template_min_max/main.cpp](31_template_min_max/01_template_min_max/main.cpp)

Утиная типизация - Duck Typing
------------------------------
t.VilyaletHvostom(); // Виляет хвостом
[32_template_duck_typing/main.cpp](32_template_duck_typing/main.cpp)

a - массив
N - количество элементов
T - параметр шаблона
произвольный тип, с которым можно выполнять
операции (т.е. он подходит по duck typing)
Вывести через запятую
2, 3, 4
[33_print_commas/main.cpp](33_print_commas/main.cpp)

Шаблон:
* template <class T>
* template <typename T>
Элемент стека и очереди:
``` cpp
template <typename T>
struct E {
  T value; // Значение элемента
  E<T>* next; // Указатель на следующий элемент
};
```

Стек
``` cpp
template <typename T = int> // Значение по-умолчанию int
struct Stack {
  E<T>* top; // Вершина стека
  // Конструктор
  Stack() : top(NULL) {}
  // Значение поместить на вершину стека
  void push(T value) {
    E<T>* newElement = new E<T>;
    // Записываем значение,
    // которое надо поместить
    // на вершину стека
    newElement->value = value;
    // Новый элемент на вершине стека
    // поэтому все остальные следуют за ним
    newElement->next = top;

    // Ставим новый элемент в начало списка
    top = newElement;
  }
  // Взять значение с вершины стека
  T pop() {
    // Запоминаем результат
    // - значение элемента-"вершины" стека
    // 1-A
    T result = top->value;

    // Запоминаем ссылку на удаляемый
    // элемент
    // 1-B
    E<T>* e = top;

    // 2. Перемещаем вершину на следующий
    top = top->next;

    // 3. Реально удаляем элемент
    delete e;

    // 4. Возвращаем результат
    return result;
  }
};
```

``` cpp
template <typename T>
struct Queue {
  E<T>* head; // "Голова" - начало очереди
  E<T>* tail; // "Хвост" - конец очереди
  // Конструктор
  Queue() : head(NULL), tail(NULL) {};
  // В конец очереди
  void put(T value) {
    // Создаём новый элемент
    E<T>* e = new E<T>;
    e->value = value;
    e->next = NULL;

    // Если очередь пуста
    if(head == NULL) {
      head = e;
      tail = e;
    } else {
      // Если в очереди уже есть элементы
      // "Присоединяем" элемент к последнему
      // элементу в очереди
      tail->next = e;
    }
  }
  // Забрать первый элемент из очереди
  T get() {
    // Запоминаем первый элемент
    E<T>* firstElement = head;
    // Значение, которое мы в конце вернём
    T value = firstElement->value;
    // Передвигаем указатель на начало
    // очереди на следующий элемент
    head = head->next;

    // Если очередь пуста, то
    // хвост очереди не указывает ни на
    // какой элемент
    if(head == NULL)
      tail = NULL;

    // Удаляем первый элемент из
    // динамической памяти
    delete firstElement;

    // Возвращаем его значение
    return value;
  }
};
```

[33_template_stack_queue/main.cpp](33_template_stack_queue/main.cpp)

Задача:
Функция, вычисляющая сумму элементов
массива с произвольным типом данных.
Понятно, что функция применима только если
элементы массива поддерживают операцию
сложения "+"
size_t - целый тип, используемый для индексации массивов
Универсальная функция суммирования
Отдельная функция для суммирования строк
Комплексное число
re - действительная часть
im - мнимая часть
Строки тоже можно "суммировать"
Это называется "Конкатенация строк"
[35_template_sum/main.cpp](35_template_sum/main.cpp)

Демонстрация "зачем нужны шаблоны"
Задача: мы хотим написать функции сортировки для всех типов данных
Если не использовать шаблоны,
то для 2 типов (int, сhar) требуется две реализации
функции сортировки
Используем простейший алгоритм сортировки
На i-ом шаге сделаем, чтобы на i-ом месте
был минимальный элемент на отрезке массива от i до конца массива
i - начало интервала, пусть j пробегает все элементы после i
на i-ом месте
Меняем два элемента
чтобы на i-ом месте стоял минимальный
элемент
Вторая реализация точно такая же, но int заменяем на char
Меняем два элемента
чтобы на i-ом месте стоял минимальный
элемент
Универсальная сортировка (для любых типов)
template <class T>
Меняем два элемента
чтобы на i-ом месте стоял минимальный
элемент
Массив целых чисел
s<int>(a,3)
Массив букв
Можно применить и к действительным числам
..и к строкам...
...и к любым другим типам данных (в том числе своим)..
..к которым применима операция "меньше"..
[36_template_sort/main.cpp](36_template_sort/main.cpp)

В цикле мы не можем создавать реализации шаблона
т.к. они создаются на этапе компиляции
error: no matching function for call to 'add(int&)'|
[38_template_many_functions/main.cpp](38_template_many_functions/main.cpp)

MyClass c1, c2;
add<MyClass>(c1,c2);
[l5_template2/main.cpp](l5_template2/main.cpp)

template: реализация структуры данных "Список"
----------------------------------------------
Шаблонная функция
Элемент списка
Конструктор
Так нельзя (!!!):
root->next = NULL;
Деструктор - метод, который вызывается при
уничтожении объекта
Добавить в начало списка
Заводим новый элемент списка в динамической памяти
Записываем в него новое значение
(*newElement).value = newValue;
Этот элемент должен встать в начало списка,
т.е. все остальные элементы будут после него.
Показать список
Текущий элемент - сначала 1-ый
Добавить элемент в конец списка
Идём до последнего элемента
for(ListElement* cur = root;
cur->next != NULL; cur = cur->next)
/* Ничего не надо делать :) */;
Создаём новый элемент
Новый элемент ставим в конец списка
myFunction<double>()
make_pair(234, 'c');
List - класс
list - объект этого класса
[l5_template/main.cpp](l5_template/main.cpp)

Базовое применение шаблонов
---------------------------
Функция в C до шаблонов
Шаблоны есть только в C++
Без использования шаблонов
Шаблонная функция
T - параметр шаблона (произвольный тип данных)
Шаблонная функция
Предусловия
Параметры шаблонов:
типы: class G / typename T
любой из типов: int I
Функция, добавляющая константу
Перегрузка операции '<' для точки
assert(2*2 == 5);
Шаблоны умеют автоматически определять
тип по типам аргументов
Явно указать параметр шаблона
[main.cpp](main.cpp)

Произведение всех чисел
в массиве A
``` cpp
template <typename T>
T mul(T A[], size_t size) {
  if(typeid(T) == typeid(int))
    cout << "int" << endl;

  if(typeid(T) == typeid(double))
    cout << "double" << endl;

  //cout << typeid(T).name() << endl;
  // TODO: реализовать
  T res = 1; // Произведение 1

  for(size_t i = 0; i < size; ++i)
    res *= A[i]; // Умножаем на все последующие

  return res;
}
```

[task_mul/main.cpp](task_mul/main.cpp)

