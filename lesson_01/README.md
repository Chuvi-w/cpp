Введение в C++
==============

Языки высокого и низкого уровня
-------------------------------

*Высокоуровневый язык программирования* - язык, нацеленный на *скорость* и *удобство* разработки (удобство программиста)
в том числе за счёт понижения эффективности использования *памяти* и процессорного *времени*.
Приближен к естественному языку.
Основная черта высокоуровневых языков - это *абстракция*, то есть введение смысловых конструкций,
кратко описывающих такие структуры данных и операции над ними,
описания которых на машинном коде (или другом низкоуровневом языке программирования) очень длинны и сложны для понимания.

*Язык низкого уровня* - близок к программированию непосредственно в машинных кодах
(или на ассемблере) используемого реального или виртуального (например, Java, Microsoft .NET) процессора.

Фокус на *скорости* и *эффективности* использования памяти.

*Основные преимущества языков низкого уровня:*
* эффективное использование процессорного времени и памяти.
* часто язык низкого уровня позволяет обратиться к ресурсам, недоступным из языка высокого уровня.
* как правило, размер исполняемого файла готовой программы получается меньше.

История создания языка C, история C++. Перспективы - язык D
-----------------------------------------------------------
* Разработан в 1972 - Деннис Ритчи, Кен Томпсон
* 1978 - Брайан Керниган и Деннис Ритчи опубликовали первую редакцию книги "Язык программирования Си"
* 1983 - Американский национальный институт стандартов (ANSI) сформировал комитет для разработки стандартной спецификации Си
* 1989 - ANSI C. Утверждён "Язык программирования Си" ANSI X3.159-1989.
* 1990 - Стандарт ANSI C был принят с небольшими изменениями Международной организацией по стандартизации (ISO) как ISO/IEC 9899:1990.
* 1999 - Стандарт C99.
* 8 декабря 2011 опубликован новый стандарт для языка Си (ISO/IEC 9899:2011).
* Язык D - http://dlang.org. Примеры на языке D: https://github.com/stden/dlang

Выбор компилятора и IDE
-----------------------
* GCC - GNU Compiler Collection - кроссплатформенный компилятор
* Visual C++ Compiler - колимпилятор под Windows от Microsoft

Установка IDE Code::Blocks. Запуск программы. Отладка
-----------------------------------------------------
* Code::Blocks: http://www.codeblocks.org/downloads/binaries - выбирайте версию вместе с MinGW (например: codeblocks-13.12mingw-setup.exe)

Опции компилятора
-----------------
* *-Wall* - показывать все предупреждения

Программа "Hello world!" на C и на C++. Отличия С и C++
-------------------------------------------------------
* [Hello world C++](/lesson_01/00_first/helloworld.cpp)
* [Hello world C](/lesson_01/00_first/helloworld.c)


Стиль оформления кода программы
-------------------------------

*Зачем?*

Одним из важнейших факторов, влияющих на способность программы к развитию, является лёгкость её *понимания*.
Одним из существенных факторов понимаемости программы, в свою очередь, является информативность исходного текста.
Если исходный текст трудно читать (он написан без соблюдения определенного стиля и системы и представляет собой
"мешанину" операторов и знаков препинания),
то вносить изменения в него очень сложно даже автору.

Рассмотрим ряд требований и рекомендаций, позволяющих выработать хороший стиль оформления программ, повышающий ее информативность.

Типичные рекомендации
---------------------

*1. Допускаются любые нарушения рекомендаций, если это улучшает читаемость*

Основная цель рекомендаций - улучшение читаемости и, следовательно, ясности и лёгкости поддержки,
а также общего качества кода.
Невозможно дать рекомендации на все случаи жизни, поэтому программист должен мыслить гибко.


Ввод и вывод данных (консоль) в C и в C++. Ввод и вывод из текстового файла
---------------------------------------------------------------------------


Литература по C/C++
-------------------
* https://vk.com/cpp_junior_developer - группа ВКонтакте

Пример: https://ideone.com/q9Vglz
Среда разработки в облаке: https://ideone.com


﻿Windows
-------

Visual Studio... Кодировка текста Windows-1251
Консоль в Windows: cp866 - для совместимости с MS-DOS

``` cpp
  setlocale(LC_ALL, "Russian");
```

Первая программа на чистом C
----------------------------
Подключаем библиотеку: **stdio.h**
``` cpp
/* Hello World на C
   Многострочный комментарий...
*/
#include <stdio.h> /* Подключаем библиотеку */
// Директива препроцессора, вставляющая содержимое файла stdio.h
// #include <stdlib.h> /* ..ещё одну библиотеку */
//#include <iostream> // Для C++

int main() {
  printf("C: Hello world!\n");
  //std::cout << "Test" << std::endl;  // Для C++
  return 0;
}
```

Кодировка файла: cp866 win1251
[01_first\helloworld.c](01_first\helloworld.c)

Первая программа на C++
-----------------------
В C++ используем библиотеку STL **iostream**
В С - библиотеки с расширением *.h*
В С++ - библиотеки без расширения
``` cpp
// Hello World на C++
#include <iostream>
#include <stdio.h> // для совместимости
#include <cstdio> // в программе на C++ подключаем C
#include <vector>
// STL - Standart Template Library

using namespace std;

int main() {
  //cout << "C++: Hello world!" << endl;
  std::cout << "C++: Hello world!" << std::endl;
  return 0;
}
```

[01_first\helloworld.cpp](01_first\helloworld.cpp)

Общая структура программы. Использование комментариев (практика: комментарии до кода)
-------------------------------------------------------------------------------------
Подключение библиотек:
Заголовочные файлы в C++ без расширения
``` cpp
#include <iostream>
#include <cstdlib>
```

Глобальные переменные:
``` cpp
int x = 1, y = 10;
```

Функции:
``` cpp
int f() {
  return 1;
}
```

Основная программа - функция *main*
``` cpp
using namespace std; // Пространство имён, чтобы не писать везде std::cin

int main() { // Основная функция
  cout << "Enter two numbers: "; // Выводим на экран
  int a, b; // Объявляем 2 переменные целого типа
  std::cin >> a >> b; // Вводим их с клавиатуры
  std::cout << a << " + " << b << " = " << a + b << std::endl; // Вывод суммы
  system("pause"); // Нажмите любую клавишу...
  return 0; // Программа завершилась удачно, 0 - код возврата
}
```

[01_first\main.cpp](01_first\main.cpp)

Чистый C
#include <stdlib.h>
[01_first\main2.c](01_first\main2.c)

C++
Вывод в консоль по-русски:
``` cpp
  setlocale(LC_ALL, "Russian");
```

[01_first\main_rus.cpp](01_first\main_rus.cpp)

Скрипт для сборки из командной строки Windows
---------------------------------------------
``` bat
@echo Build exe-file:
g++ a.cpp -Wall -O3 -o MyFile.exe
@echo Run file:
MyFile.exe
```

Сборка из командной строки
--------------------------
``` cpp
#include <iostream>

int main() {
  int i = 2 * 3;
  std::cout << "Hello world! " << i << std::endl;
  return 0;
}
```

[02_BuildCmdLine\a.cpp](02_BuildCmdLine\a.cpp)

На чистом C можно писать void main
программа при этом будет иметь код возврата 0
На C++ обязательно *int main* и *return 0;*
``` cpp
void main() {
  printf("Hello world!\n");
  return; // 0;
}
```

[02_HelloWorld_C\main.c](02_HelloWorld_C\main.c)

Использование namespace - пространств имён
------------------------------------------
Можно объявить свой cout
``` cpp
namespace my {
int cout = 10;
}

using namespace my;

int main() {
  cout << "cout = " << my::cout << endl;
  return 0;
}
```

[02_MyCout\main.cpp](02_MyCout\main.cpp)

тип имя_переменной_1, имя_переменной_2;
[02_a_plus_b\main.cpp](02_a_plus_b\main.cpp)

Побитовые операции с целыми числами
-----------------------------------
Каждый бит как логическая переменная
Пространства имён
``` cpp
namespace A {
int a;
}

namespace B {
int a;
}
```

``` cpp
int main() {
  A::a = 1;
  B::a = 2;
  // >> - побитовые сдвиг вправо
  // 101111 -> 001011
  // << - побитовые сдвиг влево
  // 00101111 -> 10111100
  int c = 3 + 5 >> 1;
  // 5 >> 1
  // 101 >> 1 -> 10

  int lp = 10 << 2;

  // Логические операции (побитовые)
  // & - И (AND)
  // 0011 & 0101 => 0001
  // | - ИЛИ (OR)
  // 0011 & 0101 => 0111
  //  0 0  -> 0
  //  0 1  -> 1
  //  1 0  -> 1
  //  1 1  -> 1
  // ^ - Исключающее ИЛИ (XOR) - не равно
  // 0011 & 0101 => 0110
  //  0 0  -> 0
  //  0 1  -> 1
  //  1 0  -> 1
  //  1 1  -> 0

  // ~ - Инверсия (NOT)
  // ~01 => 10
  // 3 = 11
  int k = ~1 & 3; // 01 -> 10
  cout << "k = " << k << endl;

  unsigned int kk = ~1;
  SHOW(kk)

  //c = 2, A::a = 4 + A::b;
  cout << "c = " << c << endl;
  return 0;
}
```

[02_bit_operators\main.cpp](02_bit_operators\main.cpp)

Подключение библиотек
#include "MyLib.h" - ваша библиотека
Своя функция
F9 - компиляция и запуск на выполнение
с ожиданием в конце нажатия клавиши
[02_first_C\main.c](02_first_C\main.c)

Пример с файлом проекта для Qt
------------------------------
Вывод Hello World на экран
[02_hw_c_qt\main.c](02_hw_c_qt\main.c)

Арифметические операции
-----------------------
``` cpp
  int a; // "int" - тип переменной, "a" - имя переменной
  cout << "a = ";
  cin >> a;

  cout << "b = ";
  int b;
  cin >> b;

  int a1, a2, a3;

  // * - умножение
  // / - деление
  // % - остаток от деления (взятие по модулю)
  cout << "a + b = " << (a + b) << endl; // В C++ используется endl вместо "\n"
  cout << "a - b = " << (a - b) << endl;
  cout << "a * b = " << (a * b) << endl;
  cout << "a / b = " << (a / b) << endl;
  cout << "a % b = " << (a % b) << endl;

  // 5 / 2 = 2
  // 7 % 4 = 3

  // Пытаемся вызвать несуществующую команду операционной системы
  system("NetTakoiComandy");
  system("pause");
```

[02_int_operations\main.cpp](02_int_operations\main.cpp)

Библиотека для работы с видео
Библиотека для работы со звуком
using namespace std;
i = 12;
[02_namespace\main.cpp](02_namespace\main.cpp)

Оператор присваивания. Операторы и их приоритеты. Скобки
--------------------------------------------------------
Операции отношения: (<, <=, >, >=, ==, !=). Логические операции (&& и ||).
Цепочки операторов
------------------
Объявляем 2 переменные
целого типа
``` cpp
  int a = 3, b = 5;
```

Сокращённая форма оператора присваивания
Сокращённые операторы (+=, -=, *=, /=, %=, ++, --).
Инкремент
Декремент
Пенять значение 2-х переменных местами
без использования 3-ей (промежуточной)
a = &p++ + (--a + ++b)
c = {     1, 2,
3, 5, 7, 10,
7, 20, 2, 3,
7, 20    }
[02_operators_chain\main.cpp](02_operators_chain\main.cpp)

Ввод и вывод данных (консоль) в C и в C++. Ввод и вывод из текстового файла
---------------------------------------------------------------------------
Программа, которая складывает два числа
Ввод и вывод из текстового файла
Раскомментировать для ввода из файла
freopen("input.txt", "r", stdin);
Раскомментировать для вывода в файл
freopen("result.txt", "w", stdout);
static int a = 3;
Ввод двух чисел
cout << "Введите A и B: ";
Сложение
Вывод результата
[03_HelloWorld_Cpp\01_helloworld_cpp\main.cpp](03_HelloWorld_Cpp\01_helloworld_cpp\main.cpp)

Виды памяти
-----------
* Статическая
* Стек: локальные переменные + вызов функций / методов
* Динамическая: new / delete, [m/c]alloc / free
*Статическая* память: глобальные переменные
``` cpp
int staticArray[1000];
int staticConsts[3] = {3, 4, 5};
```

Переменные с модификатором static.
Переменная *count* видна только внутри функции ff,
но при этом сохраняет своё значение между вызовами ff
``` cpp
int ff() {
  static int count = 0;
}
```

*Стек*: локальные переменные + вызов функций / методов
``` cpp
int f() {
  int x = 10; // в стеке
  x++;
  f();
}
```

*Динамическая*: new / delete, [m/c]alloc / free
КУЧА / HEAP
``` cpp
  int N; // = 100;
  int* p = new int[N];
  p[10] = 1;
  delete[] p;
  //p[10] =
```

[03_HelloWorld_Cpp\main.cpp](03_HelloWorld_Cpp\main.cpp)

Объявление переменных. Основные типы данных
-------------------------------------------
Целочисленные (модификаторы знаковый/беззнаковый)
``` cpp
  int N = 10;
  int a, b;
  signed int = -5;
  unsigned int = 10;
  short ss = 3;
```

Ввод и вывод данных (консоль) в C
---------------------------------
Печать значения. %d - целое число
``` cpp
  printf("N = %d\n", N);
  scanf("%d %d", &a, &b);
  /* a -> значение */
  printf("a + b = %d\n", a + b);

  a = b * b;
  printf("a = %d\n", a);
```

Ввод и вывод из текстового файла
[03_OnlyC\main.c](03_OnlyC\main.c)

Префиксная и постфиксная форма инкремента и декремента
int i = 3;
for(int i = 2; i < 10; i++)
cout << i << endl;
cout << i << endl;
[03_PostfixPrefixIncrement\main.cpp](03_PostfixPrefixIncrement\main.cpp)

Стиль оформления исходных тестов программ. Отступы, "лесенка", пробелы
----------------------------------------------------------------------
Вложенные конструкции всегда с отступом
``` cpp
void f() {
  int x = 1;
}

int main() {
  int a;
  {
    a++;
    int b;
    {
      b++;
      int c;
    }
  }
  cnt = 0;

  for(int i = 0; i < 10; ++i) {
    int x = 1;

    for(int j = 0; j < 10; ++j)
      cnt++;
  }


  return 0;
}
```

Преимущества и недостатки автоматического форматирования исходного текста программы
-----------------------------------------------------------------------------------
[03_names_format\main.cpp](03_names_format\main.cpp)

cout << "ul = " << (signed long)ul << endl;
[03_signed_usigned\main.cpp](03_signed_usigned\main.cpp)

Объявление переменных. Основные типы данных: целочисленные (модификаторы знаковый/беззнаковый), вещественные (с плавающей точкой), логический тип, символы, строки
------------------------------------------------------------------------------------------------------------------------------------------------------------------
Примитивные типы данных в C/C++
limits.h - заголовочный файл стандартной библиотеки общего назначения,
который включает определения характеристик общих типов переменных.
ЦЕЛЫЕ ЧИСЛА
-----------
Дополнительный код:
* 000 - 0
* 001 - 1
* 010 - 2
* 011 - 3
* 100 - 4  @ -4
* 101 - 5  @ -3
* 110 - 6  @ -2
* 111 - 7  @ -1 => -1
*   1 + -1 = 0
* 01 + 11 = 100
https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4_(%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%B0)
*char* 1 байт = 8 бит
U - unsigned - беззнаковые типы
S - signed - знаковые типы
cout << end;
2 байта = 16 бит
4 байта = 32 бита
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F
Двоичных констант в C/C++ нет
4 байта для 32-битной и 8 байт для 64-битной
Microsoft C++
В GNU C++ для совместимости:
#define __int64 long long
Вещественные/действительные (с плавающей точкой)
------------------------------------------------
=== Действительные числа ===
0.10101111111 * 2^(101110101)
Логический тип, символы, строки
-------------------------------
setlocale(LC_ALL, "Russian");
[03_types\main.cpp](03_types\main.cpp)

Подключение библиотек
#include "MyLib.h" - ваша библиотека
Своя функция
F9 - компиляция и запуск на выполнение
с ожиданием в конце нажатия клавиши
[04_first_cpp\main.cpp](04_first_cpp\main.cpp)

Операции
--------
[04_types_demo\main.cpp](04_types_demo\main.cpp)

﻿Отличия C и C++ (ссылки, в приведении типов, перегрузка функций)
================================================================

Ссылки:
-------
* После создания ссылки ее нельзя перевести на другой объект; в таких случаях говорят, не может быть **переопределена**. Это часто делают с указателями.
* Ссылки не могут быть null (т.е.указывать в никуда), тогда как указатели - могут; каждая ссылка ссылается на некий объект, вне зависимости от его корректности.
* Ссылки не могут быть неинициализированными. Так как невозможно переинициализировать ссылку, она должна быть инициализирована сразу после создания.
В частности, локальные и глобальные переменные должны быть проинициализированы там же,
где они определены, а ссылки, которые являются данными-членами сущностей класса,
должны быть инициализированы в списке инициализатора конструктора класса.

``` cpp
int& k; // компилятор выдаст сообщение: ошибка: 'k' declared as reference but not initialized
        // ('k' объявлена как ссылка, но не инициализирована)
```

Пример на погрешность вычислений в вещественных числах
fabs - взять по модулю
DBL_EPSILON * 1000
if( fabs((a + b) - c) < 1e-9){
[05_floats\main.cpp](05_floats\main.cpp)

Вывод ещё более длинного целого :)
signed / unsigned
знаковый / беззнаковый
'long long long' is too long for GCC
long long long lll = 912345678900L;
printf("%llld %d\n", lll, sizeof(lll));
2 знака после запятой (точки)
[06_C_printf\main.c](06_C_printf\main.c)

a = a ^ b
b = b ^ a
a = a ^ b
[07_Swap\main.cpp](07_Swap\main.cpp)

Условный оператор if
--------------------
Синтаксис:
``` cpp
  if(/*Условие*/ 1 )
    cout << "Если условие истинно!" << endl;
  else
    cout << "Если условие ложно!" << endl;

```

Всегда ложное условие
``` cpp
  if(0) {
    // Сюда мы никогда не попадём
  }

```

Всегда истинное условие
``` cpp
  if(1) {
    // Сюда мы попадём всегда
  }

```

Операции сравнения:
-------------------
* >= - больше или равно
* <= - меньше или равно
* != не равно
* !a
* > - больше
* < - меньше
* && - логическое И
* || - логическое ИЛИ
[07_if\main.cpp](07_if\main.cpp)

Условный оператор if
&& - логическое И
|| - логическое ИЛИ
! - логическое НЕ
Тернарный оператор - альтернатива if
[08_if\main.cpp](08_if\main.cpp)

Самая характерная (распространённая) ошибка при применении if
-------------------------------------------------------------
[09_if_error\main.cpp](09_if_error\main.cpp)

Минимум из двух чисел при помощи оператора if
[10_min_if\main.cpp](10_min_if\main.cpp)

Функции и области видимости
#include <conio.h> // функция getch()
Функции
Глобальная переменная
getch(); // Ожидаёт нажатие клавиши и возвращает её ASCII код
[11_function_visibility\main.c](11_function_visibility\main.c)

Объявление и вызов функций
fabs, abs
[12_CFunc\main.c](12_CFunc\main.c)

Цикл while, структуры
---------------------
Вывод на русском языке
Структура для хранения адреса
В стиле C:
В стиле C++
[14_while\main.cpp](14_while\main.cpp)

Цикл с постусловием
-------------------
Вывод числа N в двоичной системе счисления
Двоичные цифры в обратном порядке
``` cpp
  int N = 254;
  cout << "N = " << N << " = (inverse binary) = ";

  do { // Repeat
    cout << N % 2;
    N /= 2;
  } while(N > 0); // Until

  cout << endl;
```

[15_do_while\main.cpp](15_do_while\main.cpp)

``` cpp
#include <iostream>
#include <clocale>

using namespace std;

int main() {
  // Win1251 и в исходном тексте и в консоли
  setlocale(LC_ALL, "Russian");

  cout << "Программа для вычисления суммы чисел" << endl;
  cout << "Вводите целые числа для суммирования" << endl;
  cout << "Для окончания ввода введите 0" << endl;

  int sum = 0; // Текущее значение суммы

  int num;

  // Цикл с постусловием
  // Аналог repeat until в Delphi
  do {
    // Тело цикла
    cout << "Введите число: ";
    cin >> num;

    if(num != 0)
      sum += num;

  } while(num != 0);  /* Условие продолжения цикла */

  cout << "Сумма: " << sum << endl;

  return 0;
}
```

[15_do_while\main2.cpp](15_do_while\main2.cpp)

Цикл for
--------
b < 10 - игнорируется
[17_for\main.cpp](17_for\main.cpp)

Константа без типа имеет тип int в C (но не в C++)
[19_const_c\main.c](19_const_c\main.c)

Таблица умножения с выравниванием столбцов
[20_for_MulTable_homework\main.cpp](20_for_MulTable_homework\main.cpp)

Структуры C и работа с динамической памятью
Вывод на русском языке
Структура для хранения адреса
В стиле C:
В стиле C++
[21_struct\main.cpp](21_struct\main.cpp)

Ввод целых чисел
----------------
cout - объект C++
printf - функция C
[22_InputIntegers\main.cpp](22_InputIntegers\main.cpp)

Демонстрация вызова макроса
[24_ternary_C\main.c](24_ternary_C\main.c)

long double ldbl = 1.22;
printf("%L\n", ldbl);
[50_russian_console_input_output\main.c](50_russian_console_input_output\main.c)

for(инициализация; условие_продолжения;
шаг_после_тела_цикла)
0   1   2   3   4   5   6   7   8   9
ijk..
[90_homework_printf\main.cpp](90_homework_printf\main.cpp)

Пример OpenGL приложения на C
[97_OpenGL\main.c](97_OpenGL\main.c)

Двоичные константы в C при помощи макросов и побитовых операций
Удобная функция для отладки
Демонстрационные примеры
B8(01010101) = 85
B16(10101010,01010101) = 43605
B32(10000000,11111111,10101010,01010101) = 2164238933
[98_binary_constants_by_macros\main.cpp](98_binary_constants_by_macros\main.cpp)

Представление двоичных констант в C++
-------------------------------------
Рекурсивный "шаблон"
``` cpp
template<long long N>
struct bin {
  enum {
    value = (N % 8) + (bin < N / 8 >::value << 1)
  };
};

template<>
struct bin<0> {
  enum { value = 0 };
};

// Macro-processing glue: force the number to be octal to both
// end the recursion chain and make posible more digits
#define binary(n) bin<0##n>::value

// Проверка работы макроса
int main() {
  cout << bin<01000>::value << endl;
  cout << bin<1000>::value << endl;
  cout << binary(01000) << endl;
  cout << binary(1000) << endl;
  return 0;
}
```

[99_binary_constants\main.cpp](99_binary_constants\main.cpp)

Решение квадратного уравнения - разбор домашнего задания
----------------------------------------------------------
Задание:
Написать программу, которое решает квадратное уравнение.
Пользователь вводит (с клавиатуры) три действительных
коэффициента a, b, c.
Программа выводит все решения уравнения (два, одно),
"решений нет", если их нет или "бесконечно много решений",
если подходит любое значение x (a = 0, b = 0, c = 0).
Обработать все варианты исходных данных.
a*x^2 + b*x + c = 0
Функция
[HW\main2.cpp](HW\main2.cpp)

Решение квадратного уравнения
-------------------------------
Задание:
Написать программу, которое решает квадратное уравнение.
Пользователь вводит (с клавиатуры) три действительных коэффициента a, b, c.
Программа выводит все решения уравнения (два, одно), "решений нет",
если их нет или "бесконечно много решений", если подходит любое значение x (a = 0, b = 0, c = 0).
Обработать все варианты исходных данных.
``` cpp
void solve_equation(double a, double b, double c) {
  // TODO: реализовать
}
```

``` cpp
  // Коэффициенты квадратного уравнения
  double a, b, c;
  // a*x^2 + b*x + c = 0
  cout << "a = ";
  cin >> a;
  cout << "b = ";
  cin >> b;
  cout << "c = ";
  cin >> c;
  cout << endl;

  // Вызов функции решения квадратного уравнения
  solve_equation(a, b, c);
```

[HomeWork\main.cpp](HomeWork\main.cpp)

Комментарии C++
Подключение библиотеки
[main.cpp](main.cpp)

Макросы и константы
-------------------
[template.cpp](template.cpp)

